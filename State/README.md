# State  


**상태를 클래스로 표현한다.**  
상태를 클래스로 표현하면 클래스를 **교체**해서 상태의 **변화**를 표현할 수 있고, 새로운 상태를 추가해야 할 때 무엇을 프로그래밍하면 좋을 지 분명해진다.  

## 예제 1

**금고 경비 시스템**  

```
경비센터와 접속한 금고가 1개 있다.  
금고에는 금고사용 버튼, 비상벨, 일반통화용 전화가 접속되어 있다.  
금고에는 시계가 설치되어 있어 현재의 시간을 감시하고 있다.  

금고는 주간에만 사용할 수 있다.  
주간에 금고를 사용 : 경비센터에 사용기록  
야간에 금고를 사용 : 경비센터에 비상사태 통보

비상벨은 언제나 사용할 수 있다.  
비상벨 사용 : 경비센터에 비상사태 통보  

일반통화용 전화는 언제나 사용할 수 있다.(야간은 녹음만 가능하다.)  
주간 전화 사용 : 경비센터 호출  
야간 전화 사용 : 경비센터의 자동응답기 호출  
```

보통 State 패턴을 사용하지 않았다면, 위의 로직을 모두 if-else 문으로 분기하여 구현했을 것이다.  
State 패턴은 아예 다른 관점으로 생각하고 프로그래밍 한다.  
주간과 야간의 **상태를 클래스로 표현**한다.  
상태가 클래스로 표현되어 있기 때문에, **상태 검사를 위한 if문이 등장하지 않는다.**  

```
'주간' 상태를 표현하는 클래스 {
    금고 사용시에 호출되는 메소드() {
        경비 센터에 이용기록
    }
    비상벨 사용시 호출 메소드() {
        경비센터에 비상벨 통보
    }
    일반 통화 호출 메소드() {
        경비센터의 호출
    }
}
'야간' 상태를 표현하는 클래스 {
    (구성은 위와 같고, 메소드별 처리는 다름)
}
```
* State 인터페이스
    * 금고의 상태를 나타낸다.
    * 시간 설정, 금고사용, 비상벨 사용, 일반통화 사용 이라는 사건에 대응해서 호출되는 **인터페이스**를 선언하고 있다.  
    * **상태의존 메소드의 집합니다.**
    * 각 메소드의 인수로 Context가 전달된다.
* DayState 클래스, NightState 클래스
    * 각각 주간 / 야간 상태를 나타내는 클래스이다.  
    * State 인터페이스를 구현하고 있다.  
    * **Singleton 패턴**을 이용하여 각 상태에 대해 한 개씩만 인스턴스를 만든다.(```static```)
    * ```doClock``` 메소드는 시간을 설정한다. 
        * **DayState(주간 상태) 클래스에서 인수로 제공된 시간이 야간이면 야간의 상태로 시스템을 이행한다.** 여기서 상태의 변화가 일어난다.  
            * Context 인터페이스의 ```changeState``` 메소드를 사용해서 상태의 변화를 표현하고 있다.  
            * 이행될 상태 클래스에 ```getInstance()``` 메소드를 사용하여 얻고 있다.(여기서 **Singleton 패턴**을 사용하여 ```new```로 선언하지 않는 것에 주목)
    ```
    // DayState 클래스의 doClock 메소드
    public void doClock(Context context, int hour) {
        if(hour < 9 || 17 <= hour) {
            context.changeState(NightState.getInstance());
        }
    }
    ```
    * ```doUse```, ```doAlarm```, ```doPhone``` 메소드는 각각 금고사용, 비상벨사용, 일반통화 사용시에 대응한 메소드이다. 
        * 각 메소드가 하는 일은 Context의 메소드를 호출해서 필요한 일을 수행할 뿐이다.  
        * **현재 상태를 검사하는 if문이 없다는 것이 주목하자.**
        * 각 상태 메소드를 구현할 때, 항상 현재의 상태는 주간(야간) 상태이다. 라는 점을 염두에 두고 구현을 하게 된다.  
        * **상태의 차이가 곧 클래스의 차이로 표현되기 때문에, 분기 로직이 필요없다.**  
* Context 인터페이스 
    * 상태를 관리하거나 경비센터의 호출을 수행한다.  
* SafeFrame 클래스 
    * GUI를 사용해서 금고 경비 시스템을 실현한다.  
    * Context 인터페이스를 구현한다.  
    * ActionListener 라는 인터페이스 또한 구현한다.  
        * 각 버튼의 ```addActionListener``` 메소드를 호출해서 Listener를 설정한다.  
        * 이 때 메소드의 인수에 '버튼이 눌렸을 때에 호출되는 인스턴스'를 지정한다.  
        * 그 메소드의 인수는 모두 ActionListener를 구현하고 있을 필요가 있다.  
        * 여기에서는 ```this```를 통해 SafeFrame의 인스턴스를 지정하고 있고, SafeFrame 클래스는 역시 ActionListener를 구현학 ㅗ있다.  
        * 버튼이 눌러졌을 때에 listener가 호출되는 기구는 [**Observer 패턴**](../Observer/README.md)과 유사하다.
    * ```actionPerformed``` 메소드는 버튼이 눌러졌을 때에 호출되는 메소드이다.  
        * 이 메소드는 ActionListener 인터페이스에서 선언된 메소드 이름이기 때문에 변경해서는 안된다.  
        * 어떤 버튼이 눌러졌는지 조사해서 그에 대응하는 처리를 한다.
        * 여기에서 if문이 등장하지만, 이 if문은 버튼 각각의 대한 처리이지 상태에 대한 처리가 아닌 것을 주의한다. 
        * **금고사용 버튼을 눌렀을 때, ```state.doUse(this);``` 라는 구문이 현재의 상태를 조사하지 않고 바로 실행되는 것. 이게 State 패턴이다.**
        
    * ```setClock``` 메소드 에서는 현재 시각을 지정한 시각으로 설정한다.  
        * 시간을 조사후, 현재의 상태에 따른 처리를 수행한다.(**이 안에서 상태의 전환이 일어난다.**)
        ```
        state.doClock(this, hour);
        ```
    * ```changeState``` 메소드는 DayState 클래스나 NightState 클래스에서 호출된다. 
        * 상태 전환이 일어날 때 호출되는 메소드이다. 
        * 실제 상태 전환은
        ```
        this.state = state;
        ```
        라는 문으로, **현재의 상태를 나타내고 있는 필드에 상태를 나타내는 클래스의 인스턴스를 대입하는 것으로 수행한다.**
* Main 클래스  
    * SafeFrame의 인스턴스를 한 개 만들어 ```setClock``` 메소드를 이용해 시간을 설정한다.  

## 정리

### State(상태)
상태가 변할 때마다 다른 동작을 하는 Interface를 결정한다.  
이 인터페이스는 **상태에 의존한 동작을 하는 메소드의 집합**이 된다.  
예제 1의 State 인터페이스가 해당된다.  

## ConcreteState  
구체적인 각각의 상태를 표현한다.  
예제 1의 DayState, NightState가 해당된다.  

### Context(상황, 전후관계, 문맥)
현재의 상태를 나타네는 ConcreteState 역할을 필드로 가진다.  
또한 State 패턴 이용자에게 필요한 인터페이스를 제공한다.  
예제 1의 Context 인터페이스와 SafeFrame 클래스가 해당된다.  
예제 1에서는 Context 인터페이스가 인터페이스(API)를 결정하는 부분을 담당하고,  
SafeFrame 클래스가 ConcreteState 역할을 가지는 부분들을 담당했다.  

## Hint

### 분할해서 통치하라.  

> 분할해서 통치해라.

복잡하고 규모가 큰 프로그램을 취급할 경우의 방침이다.  
문제를 작은 문제로 나누고, 그래도 해결하기 힘들면 더 작은 문제로 나눈다.  
문제를 간단하게 해결할 때까지 작게 나누어서 해결한다.  

State 패턴에서는 '상태'를 클래스로 표현했다.  
각각의 구체적인 상태를 클래스로 표현해서 문제를 분할한 것이다.  
해당 상태의 클래스를 개발하는 동안에는 **다른 클래스에 대한 생각을 잠시 잊고 개발을 할 수 있다.**  
> **State 패턴은 상태가 많아질 때 장점이 발휘된다.**  

State 패턴을 사용하지 않고 많은 상태를 조건으로 분기하게 되면, 상태가 많아질수록 조건 분기도 증가하게 되고, 비슷한 조건 분기를 사건이 발생할 때마다 호출되는 메소드에 전부 기술해야 한다.  

> **State 패턴은 '상태'를 클래스로 표현해서 복잡한 프로그램을 분할하고 있다.**  

### 상태에 의존한 처리  

SafeFrame 클래스의 ```setClock``` 메소드는 Main 클래스에서 호출되고 있다.  
Main으로부터'시간의 설정'을 지시받아 메소드 내부에서는 다음과 같이 처리한다.  
```
state.doClock(this, hour);
```
**State에 위임하고 잇다.**  
즉, 시간의 설정을 **현재의 상태에 의존한 처리**로 취급하고 있다.  

State 인터페이스로 선언되고 있는 메소드는 모두 상태에 의존한 처리히고, 상태에 따라 동작이 달라니느 처리이다.  

이 상태에 의존한 처리를 다음과 같이 표현하고 있다.  
> 추상 메소드로서 선언하고 인터페이스로 한다.  
> 구상 메소드로서 구현하고 각각의 클래스로 한다.  

### 상태의 전환은 누가 관리해야 하는가?  

예제 1에서는 Context 역할인 SafeFrame 클래스가 상태전환을 실제로 수행하는 ```changeState``` 메소드를 구현했다.  
이 메소드를 호출하는 것은 DayState나 NightState 클래스이다.  
즉, **상태전환**을 **상태에 의존한 동작**으로 간주하고 있다.  

장점 : DayState 클래스가 다른 상태로 전환하는 것은 언제인지 알고 싶을 때, DayState 클래스의 코드를 읽기만 하면 된다. 즉, **다른 상태로 전환하는 것은 언제인지의 정보가 하나의 클래스 내에 정리되어 있다**  
단점 : **하나의 ConcreteState 역할이 다른 ConcreteState 역할을 알아야 한다.**  
즉, **상태 전환을 ConcreteState 역할에 맡기면, 클래스 사이의 의존관계를 깊게한다.**  

예제 1과 다르게, 모든 상태전환을 Context 역할의 SafeFrame 클래스에 맡길 수 있다.  

장점 : ConcreteState 역할의 독립성이 높아져서 프로그램 전체 예측에 좋다.  
단점 : Context 역항리 모든 ConcreteState의 역할을 알아야 한다.  
(여기에 [**Mediator 패턴**](../Mediator/README.md)을 적용할 수 있을지 모른다.)

### 자기 모순에 빠지지 않는다.  

상태를 나타내는 변수는 단 하나이다.  
예제 1은 SafeFrame 클래스의 ```state``` 필드이다.  
시스템의 상태를 확실하게 결정하기 때문에 자기 모순에 빠지지 않는다.  

> 시스템의 상태가 복수의 변수 값의 집합으로 표현되어 있다고 가정하면, 이때 변수 값 사이에 자기 모순이나 불균형이 없어야 한다.  

### 새로운 상태를 추가하는 것은 간단하다.  

새로운 상태를 추가하는 것은 ConcreteState 클래스를 하나 더 추가하기만 하면 된다.  
상태 전환에 대한 접점에 주의하기만 하면 된다.  

상태 의존의 처리를 추가하는 것은 곤란한다.  
State 인터페이스에 메소드를 추가하고, ConcreteState 역할에 처리를 추가하는 일이 되기 때문이다.  

하지만 잊어버릴 위험은 없다. 컴파일 시에서 에러가 발생하기 때문에.  

### 두 얼굴의 인스턴스  

예제 1의 SafeFrame 클래스 안에 아래 2개의 문이 등장한다.  

```
SafeFrame의 생성자 안 : buttonUse.addactionListener(this); // ActionListener의 구현체의 인스턴스  
actionPerformed 메소드 안 : state.doUse(this); // Context의 구현체의 인스턴스
```

다음의 두 ```this```는 조금의 차이가 있다. 각 메소드가 받고 있는 인수 형태가 다르기 때문이다. 

### 관련 패턴

* Singleton 패턴  
ConcreteState 역할은 Singleton 패턴으로 구현된다.  
상태를 나타내는 클래스를 인스턴스 필드(즉, 인스턴스의 상태)를 가지고 있지 않기 때문이다.  
* Flyweight 패턴  
상태를 표시하는 클래스는 인스턴스를 갖지 않는다.  
따라서 Flyweight 패턴을 이용해서 ConcreteContext 역할을 복수의 Context 역할에서 공유할 수 있는 경우가 있다.  