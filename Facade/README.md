# Facade

커다란 프로그램을 사용해서 처리할 때, 상호 관련된 많은 클래스를 적절하게 처리하기 위한 **창구**를 준비해두는 것이 좋다.  
복잡하게 얽혀 있는 것을 정리해서. 높은 레벨의 인터페이스를 제공한다.  
시스템의 외부에 대해서는 단순한 인터페이스를 보여주고, 시스템 내부에 있는 각 클래스의 역할이나 의존관계를 생각해서 정확한 순서로 클래스를 이용한다.  

사용자는 창구 API만 사용만 하면 되는 것.

## 예제 1

**웹 페이지 작성 프로그램**  

* Database 클래스
    * 데이터 베이스 이름을 지정하고 Properties를 작성하는 클래스.  
* HTMLWriter 클래스
    * 간단한 웹 페이지 HTML를 출력하는 메소드.
    * 이 메소드는 ```title``` 메소드를 제일 먼저 호출해야 하는 제약이 있다.
* PageMaker 클래스 
    * Database 클래스와 HTMLWriter 클래스를 조합해서, 웹페이지를 작성하기 위한 클래스
    * 정의되어 있는 Public 메소드는 ```makeWelcomePage``` 메소드 뿐이다.  
    * **외부에 대해서는 단 하나의 ```makewelcomePage``` 메소드만을 보이고 있다.**
* Main 클래스
    * PageMaker 클래스 단 하나를 이용한 문장 하나뿐으로 이루어져 있다. 
    ```
    public static void main(String[] args) {
        PageMaker.makeWelcomePage("yeoseon@gmail.com", "welcome.html");
    }
    ```

## 정리

### Facade
**단순한 창구**  
높은 레벨에서 단순한 인터페이스를 시스템 외부에 제공한다.  
예제 1의 PageMaker가 해당된다.  

### 시스템을 구성하는 많은 역할 클래스 
각각의 임무를 실행하는 클래스  
Facade 역할에 대해서는 신경쓰지 않는다.  
Facade 역할에서 이 클래스를 호출하지만, 이 클래스들에서 Facade 클래스를 호출하는 일은 없다.  
예제 1의 HTMLWriter와 Database가 해당된다.  


## Hint

### Facade의 역할

복잡한 것을 단순하게 보여준다.  
> 인터페이스(API)를 적게하는 것이 핵심이다.

클래스나 메소드를 많이 보여주게 되면, 사용자는 무엇을 사용할지, 어떤 순서로 호출할지 주의해야 한다. 이는 틀리기 쉽다는 것과 같다.  

> 인터페이스의 수가 적다는 것은, 외부와의 결합이 소원하다고 표현할 수 있다.  
> 이는 패키지를 부품으로써 재이용하기 쉽게 해준다는 것과 같다.  

> 클래스를 설계할 때는 어떤 메소드를 Public으로 할 지 고민해야 한다.  

너무 많은 클래스를 Public으로 하게되면, 내부를 수정하기 힘들게 된다.  

필드에 대해서도 마찬가지다. 
> 필드를 public으로 하면 그 필드의 내용을 멋대로 참조하거나 변경하기 때문에 클래스의 수정이 힘들게 된다.  

> 또한, 패키지 설계시에도 어떤 클래스를 public 으로 할 것인지도 생각해야 한다.  

### 재귀적인 Facade 패턴의 적용

Facade의 역할을 가진 클래스의 집합을 정리해서, 새로운 Facade 역할을 도입할 수 있다.  

### 프로그래머가 Facade를 만들지 않는 이유

> 어떤 프로그래머가 '이 클래스를 호출하기 전에는 이 것을 호출하고, 이 메소드를 호출하기 전에는 이 클래스에 등록해 둘 필요가 있다.'는 말을 할 때에, Facade 패턴을 도입할 필요가 있다는 것과 같다.  

> **확실하게 언어로 표현할 수 있는 노하우는 프로그래머의 머리 속에 숨겨둘 것이 아니라, 코드로서 표현해야 한다.**

### 관련패턴
* Abstract Factory 패턴  
'객체 생성' 이라는 복잡한 작업에 대한 Facade 패턴으로 간주할 수 있다.  
**객체를 생성하기 위해서는 이것만 호출하면 OK**  

* Singleton 패턴  
Facade는 Singleton 패턴으로 만들어지는 경우가 많다.  

* Mediator 패턴  
Facade 패턴에서는 Facade 역할이 **일방적으로** 다른 역할을 이용해 높은 레벨의 인터페이스를 제공한다.  
Mediator 패턴에서는 쌍방향으로 동작한다.  