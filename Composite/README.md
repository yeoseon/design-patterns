# Composite  

그릇과 내용물을 동일시해서 재귀적인 구조를 만들기 위한 디자인 패턴  

## 예제 1

**파일과 디렉터리를 도식적으로 표현한 프로그램**  

* Entry 클래스  
    * File과 Directory를 동일시 하는 **추상** 클래스
    * 이름을 얻기 위한 ```getName()``` 메소드와 크기를 얻기 위한 ```getSize()``` 메소드를 가지고 있다.  
    * 디렉터리 안에 파일이나 디렉터리 (즉, 엔트리)를 넣는 메소드 ```add()```가 정의되어 있고, 하위 Directory 클래스에서 이를 구현한다.  
    * ```toString()``` 메소드에서는, 추상 메소드인 ```getName()```과 ```getSize()```를 이용해서 알고리즘을 구현하고 있다. (**Template 메소드**)
* File 클래스 
    *  ```name```과 ```size``` 필드가 선언되어 있어, 생성자의 인수로 받고 있다.  
    * Entry 클래스에 정의된 추상 클래스들을 구현하고 있다.
* Directory 클래스
    * ```name```을 필드로 가지고 있다. 
    * ```size```는 동적으로 생성되는 값으로서, 필드로 가지고 있지 않고 함수로 구현해 바로 return 한다.
    *  ```getSize()``` 에서는 재귀를 통한 호출을 하고 있다. ```entry```에 해당하는 것이 File일지, Directory일지 모른다.  
        ```
        size += entry.getSize();
        ```
        > Composite 패턴의 재귀적 구조가 ```getSize```라는 메소드의 재귀적 호출에 대응하고 있는 것이다.  
        * 추가적인 Entry의 하위 클래스가 만들어져도, getSize()메소드를 구현하고 있기 때문에 Directory에서는 이 부분을 수정 할 필요가 없다.
    * ArrayList로 선언된 directory 인스턴스에 하위 entry를 더할 때도, 해당 entry가 File인지 Directory인지 조사할 필요 없이 ```add()```를 통해 넣기만 하면된다.
        * 여기서 'add'하는 조작은 ArrayList에 **위임**하고 있다고 말할 수 있다.
    * printList에서도 Composite 패턴을 통한 재귀 호출을 수행하고 있다. 
        ``` 
        entry.printlist(...)
        ```
* FileTreatmentException 클래스
    * File에 Entry를 add 하려고 할 때의 처리를 위한 클래스이다.
    * 이렇게 에러에 대한 처리 방법은 뒤에서 살펴본다.

## 정리

### Leaf (나뭇잎)

'내용물'을 표시하며, 안에는 아무것도 넣을 수 없다.  
예제 1의 File이 이 역할을 수행한다.  

### Composite (복합체)  

'그릇'을 표시하며, Leaf나 또 다른 Composite을 넣을 수 있다.  
예제 1의 Directory가 이 역할을 수행한다.  

### Component  

Leaf와 Composite을 **동일시**하는 역할을 수행한다.  
Leaf 역할과 Composite 역할에 공통적인 상위 클래스로 정의한다.  
예제 1의 Entry가 이 역할을 수행한다. 

### Client

Composite 패턴의 사용자.  
예제 1에서는 Main이 이 역할을 수행한다.  
Component 역할을 부모에 대한 **자식**으로 간주한다.  

## Hint

### 복수와 단수의 동일시  

그릇과 내용물을 동일시 하는 동시에, 복수와 단수 역시 동일시하고 있다고 할 수 있다.  

예)  
Test1에서는 키보드를 통한 입력테스트를 실행.  
Test2에서는 파일에서의 입력테스트를 실행  
Test3에서는 네트워크 에서의 입력테스트를 실행.  
 -> Test1,2,3을 합해서 '입력테스트'로 정의 할 때, Composite 패턴을 사용. 

또 다른 출력 테스트를 보아서 '출력테스트'로 정의 후에,  
이 둘을 모아 '입출력 테스트'로 정의가 가능하다.  

### ```add``` 메소드의 구현 방법 (에러 처리)  

예제 1에서는, ```add```를 실제로 실행할 수 있는 클래스는 Directory 뿐이다.  
이를 처리하기 위한 방법에는 3가지가 있다. 

1. Entry 클래스에서 구현하고 에러 처리  
예제 1과 같은 처리이다. ```add``` 메소드를 Entry 클래스 내에 구현하고, File이 해당 메소드를 쓸 경우, 예외 처리를 했다.  
File 클래스를 Entry 클래스에서 ```add``` 메소드를 상속하고 있기 때문에, **사용은 가능*** 하지만, 예외 처리된다.  

2. Entry 클래스에서 구현하고 아무 처리도 하지 않는다.  
Entry 클래스에서 구현하지만, 에러처리를 하지 않고 'do nothing' 으로 처리하는 방안도 있다.  

3. Entry 클래스에서 선언은 하지만, 구현은 하지 않는다.  
```add``` 메소드를 Entry 클래스 내에 **추상 메소드**로 정의하여, 하위 클래스에서는 필요하면 정의하고, 필요하지 않으면 에러처리 하는 방법도 있다.  
이 방법은 일관성을 가질 수 있고, 불필요한 경우, 하위 클래스에서 처리할 수 있는 장점이 있으나,  ```add```가 필요가 없는 File 클래스 내에서 굳이 에러처리를 위해 구현을 해야한다.  

4. Directory 클래스에만 넣는다.  
Entry 클래스에 넣지 않고, Directory 클래스에만 넣는 방법이다. 이 방법은 Entry 변수에 add 할 때, 하나하나 Directory 형으로 캐스트 해야하는 불편함이 있다.  


### 재귀적 구조는 모든 장면에서 등장한다.  

프로그래밍을 할 때, 재귀적 구조는 많이 등장한다.  
일반적으로 트리구조로 된 데이터 구조는 Composite 패턴에 해당한다.  

### 관련 패턴

* Command 패턴  
Command 패턴에서 '매크로 커맨드'를 만들 때, Composite 패턴이 사용된다.    
* Visitor 패턴  
Composite 패턴을 순환하면서 처리하는데 사용한다.    
* Decorator 패턴  
Composite 패턴이 '그릇'과 '내용물'을 동일시 한다면, Decorator 패턴은 '장식'과 '내용물'을 동일시 한다.