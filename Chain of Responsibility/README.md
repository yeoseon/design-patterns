# Chain of Responsibility  

**책임 떠넘기기**
복수의 객체를 사슬처럼 연결해두면, 그 객체의 사슬을 차례대로 돌아다니면서 목적한 객체를 결정하는 방법  
**요청하는 쪽**과 **처리하는 쪽**의 연결을 **유연하게** 하여 각 객체를 부품으로 독립시킬 수 있고, 요청을 처리할 객체가 변하는 프로그램에도 대응할 수 있다.   

## 예제 1

**트러블 처리 프로그램**  

* Trouble 클래스  
    * 발생한 트러블을 표현하는 클래스
    * Number : 트러블 번호
* Support 클래스
    * 트러블을 해결할 사슬을 만들기 위한 **추상** 클래스
    * ```next``` 필드 : 떠넘기는 곳
    * ```resolve()``` : 하위 클래스에서 구현할 **추상** 클래스 
        * 반환값이 true : 요구가 처리되었다.
        * 반환값이 false : 요구가 처리되지 않아, 다음으로 떠넘긴다.
    * ```support()``` : ```resolve``` 메소드를 호출하고, 그에 대한 값이 false면 **떠넘기기~~를 수행하는 메소드. 
        * 다음 사람이 없는 경우 최종 실패의 메시지를 띄운다.
        * ```resolve``` 메소드를 사용한 Template 패턴을 이용해 알고리즘을 구현했다.  
* NoSupport, LimitSupport, OddSupport, SpecialSupport
    * 추상 클래스인 Support 클래스의 ```support``` 메소드를 실제로 구현한 구체적인 처리자 클래스이다.
* Main 클래스
    * 트러블 해결자를 작성한다. Support 클래스형의 변수를 사용하고, 실제로 대입되고 있는 것은 구체적인 해결자이다.
    ```
    Support alice = new NoSupport("Alice");
    Support bob = new LimitSupport("Bob", 100);
    ...
    ```
    * 다음으로 ```setNext``` 메소드를 사용하여, 트러블을 처리할 연결고리를 작성한다. 
    ```
    alice.setNext(bob).setNext(charlie).setNext(diana);
    ```
    * 마지막으로 다양한 트러블을 발생시켜 ```support``` 메소드를 사용한다.
    ```
    for (int i = 0; i < 500; i ++) {
        alice.support(new Trouble(i));
    }
    ```

## 정리

### Handler(처리자)
요구를 처리하는 인터페이스를 결정하는 역할을 한다.  
예제 1의 Support가 해당된다. 

### ConcreteHandler   
요구를 처리하는 구체적인 역할을 수행한다.  
예제 1의 여러가지 Support 클래스가 해당된다.  

### Client
예제 1의 Main 클래스가 해당된다.  

## Hint

### 요구하는 사람과 요구를 처리하는 사람을 유연하게 연결한다. 

> 요구를 하는 사람과 요구를 처리하는 사람을 유연하게 연결하는 것이 포인트.  

만약, 이 패턴을 사용하지 않는다면, "이 요구는, 이 사람이 처리해야 한다." 라는 정보를 누군가가 **중앙집권적으로 가지고 있어야 한다.**  
> 이 정보를 요구를 하는 사람에게 갖게 하는 것은 현명하지 않다.  
> 요구를 하는 사람이 처리자들의 역할 분담까지 자세하게 알아야 한다면, 독립성이 훼손되기 때문이다.  

### 동적으로 사슬의 형태를 바꾼다.  
예제에서는 사슬의 형태가 고정된 경우 이지만, 요구 처리의 ConcreteHandler의 객체 관계가 동적으로 변화해야하는 상황이 생길 수 있다.  
**위임**을 통해 떠넘기기를 실행하고 있기 때문에, 상황의 변화에 따라서 역할을 재편할 수 있다.  

하지만 이 패턴을 사용하지 않으면, 대응관계가 고정적으로 기술되어 있어, 프로그램 실행중에 처리자를 변경하기 어렵게 된다.  

윈도우 시스템에서는 사용자가 윈도우 상에 컴포넌트를 자유롭게 추가할 수 있는 경우에 이 패턴이 유효하다.

### 자신의 일에 집중할 수 있다.  
> 각 오브젝트가 자신의 일에 집중할 수 있다.  

이 패턴을 사용하지 않을 경우, "위대한 한 사람이 누가 요구를 처리할 지 전부 결정하는 방법"으로 진행하게 된다. 또한, 이를 통해 처리할 수 없으면 다른사람에게 떠넘기는 분담의 역할 까지 각각의 ConcreteHandler에게 부담시켜야 한다.  

### 처리가 지연되지 않을까?

> 요구와 처리자의 관계가 **고정적**이고, **처리 속도가 상당히 중요한 경우**에는 이 패턴을 사용하지 않는 것이 유효할 수 있다. 

### 관련패턴
* Composite 패턴  
Handler 역할에는 Composite 패턴이 자주 등장한다.  
* Command 패턴
Handler 역할에 의해 제공되는 '요구'에는 Command 패턴이 사용되는 경우가 있다.  