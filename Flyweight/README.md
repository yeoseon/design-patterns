# Flyweight    

**객체를 가볍게 하기위한 패턴**  
```new```를 통해 생성하는 클래스의 인스턴스가 많이 필요한 경우, ```new```를 계속 하면서 생성하면 메모리 사용량이 증가된다.  

이를 해결하기 위해  
> 인스턴스를 가능한 대로 공유시켜서 쓸데없이 ```new```하지 않도록 한다.  
는 것이 바로 Flyweight 패턴이다.  

## 예제 1

**문자를 모아서 큰 문자를 만드는 프로그램**  

BigChar 라는 큰 문자를 표현하는 클래스를 읽어들여 메모리에 저장한다. 메모리를 소비하기 때문에, 이 클래스의 인스턴스를 공유하는 방법을 생각해본다.  
BigCharFactory 클래스가 BigChar 클래스의 인스턴스를 만든다. 그러나 **같은 문자에 대응하는 BigChar 클래스 인스턴스가 이미 만들어진 경우에는 그것을 이용**하고, 그렇지 않은 경우에만 새로운 인스턴스를 생성한다.  
만들어진 인스턴스는 ```pool``` 이라는 필드에 보관된다.  
Java에서 제공하는 ```java.util.HashMap```을 이용하여 **고속으로 판단**할 수 있도록 한다.  

[java.util.HashMap 참고](https://github.com/yeoseon/tip-archive/issues/57)

* BigChar 클래스  
    * '큰 문자'를 나타내는 클래스  
    * 인수로 주어진 문자에 맞게 여러 기호로 크게 작성한 문자열은 ```fontdata``` 필드에 저장된다.  
    * 앞으로 이 클래스를 공유하여 사용할 것이다. 공유의 역할은 BigCharFactory를 통해 수행하게 될 것이다.  
* BigCharFactory 클래스
    * BigChar의 인스턴스를 생성하는 공장  
    * ```pool``` 필드는 지금까지 만든 BigChar의 인스턴스를 관리한다.  
    * ```java.util.HashMap```은 문자열(key) -> 인스턴스(value)의 형태로 관리하기 위해 사용된다.  
    * BigCharFactory 클래스는 **singleton패턴**을 사용해서 구현하고 있다.  
    * **인수로 제공된 문자에 대응하는 BigChar 인스턴스를 만든다. ```pool```을 검사해서 이미 동일한 문자에 대응하는 인스턴스가 만들어져 있으면 새로운 인스턴스를 만들지 않고 이전의 만든 인스턴스를 반환값으로 한다.**  
* BigString 클래스  
    * BigChar을 모아 만든 '큰 문자열' 클래스이다.  
    * BigCharFactory 클래스를 ```getInstance()```를 통해 얻는다. (**singleton패턴을 사용했으므로**)  
    * 얻은 BigCharFactory 클래스의 인스턴스를(```factory```)통해 BigChar 클래스를 얻는다. **이때 ```new```를 사용하는 것이 아니라, ```factory``` 인스턴스의 ```getBigChar``` 메소드를 이용해서 얻으며, BigCharFactory 클래스의 ```getBigChar``` 메소드 내에서 Flyweight패턴의 공유 처리를 하고 있는 것이다.**  


## 정리

### Flyweight(플라이급)

평소대로 취급하면 무거워지기 때문에 **공유하기 좋은 것**을 나타낸다.  
예제 1의 BigChar 클래스가 해당된다.  

### FlyweightFactory  

Flyweight 역할을 만드는 공장의 역할이다.  
이 공장을 이용할 경우, 인스턴스가 공유된다.  
예제 1의 BigCharFactory 클래스가 해당된다.  

### Client  

**FlyweightFactory 역할을 사용**해서 Flyweight 역할을 만들고, 그를 이용한다.  
예제 1의 BigString 클래스가 해당된다.  

## Hint

### 공유되면, 여러 장소에 영향을 미친다. 

가장 주의해야할 점이다.

> **공유하고 있는 것을 변경하면, 여러 장소에 영향을 미친다.**  

하나의 인스턴스를 변경하면, 그 인스턴스를 사용하고 있는 여러 장소에 영향을 미친다는 말이다.  
이 점이 항상 나쁘다는 것이 아니다. **프로그램이 취급하는 문제에 따라서 좋은 점도 있고, 나쁜 점도 있다.**  

어쨌든 이 특성을 알고 개발하라는 것이다.  

따라서 Flyweight 역할에게 제공하는 정보는 **신중하게** 선택해야 한다.  
반드시 여러 장소에 공유시켜야 할 정보만을 Flyweight 역할에게 제공하는 것이 좋다.  

예제 1을 통해 예를 들어보자.  

> * BigChar에게 '색'의 정보를 제공하자.  
> * BigChar의 인스턴스는 공유되기 때문에 '색'의 정보도 같이 공유된다.  
> * 즉 BigString 안에서 사용되는 동일한, 공유되는 BigChar 인스턴스는 반드시 모두 **동일한 색**을 가지게 된다. <- 영향을 미친다.  

> * 이번엔 BigChar가 아닌 BigString에게 '색'의 정보를 제공하자.  
> * '3번째의 문자는 빨강'이라는 색 정보를 BigString이 관리하게 되는 것.  
> * 이 때는 BigChar의 인스턴스라도, 다른 색으로 할 수 있다.  

두 가지 중에서 어느 쪽이 옳은가는 결정할 수 없다.  
**클래스의 사용 목적에 따라 달라지기 때문이다.**  
**무엇을 공유시킬지 주의해야 한다.** 


### intrinsic와 extrinsic  

공유시키는 정보(intrinsic)와 공유시키지 않는 정보(extrinsic)  

intrinsic 정보  
* 인스턴스를 어디에서 가지고 있더라도 어떠한 상황에서도 변하지 않는 정보  
* 상태에 의존하지 않는 정보  
* 예제 1의 BigChar의 ```fontdata```에 해당된다.  

extrinsic 정보  
* 인스턴스를 두는 장소에 따라서 변화하는 정보  
* 상황에 따라서 변하는 정보  
* 상태에 의존하는 정보  
* 예제 1에서 BigChar의 인스턴스가 BigString의 몇 번째 문자인가 하는 정보 등에 해당된다.  

위에서 예시로 든 **색**에 대한 정보도 intrinsic 정보와 extrinsic 정보 중 **어떤 정보로 취급할 것인가**로 고민할 수 있다.  

### 인스턴스와 Garbage collection  

[Garbage collection 참고](https://github.com/yeoseon/tip-archive/issues/58)

예제 1을 참고해서 보자.  
```java.util.HashMap```을 통해 생성한 BigChar 인스턴스를 관리하고 있다.(```pool```)  

이와 같이 **인스턴스를 관리**하는 기능을 Java에서 실현할 때에는 반드시 **관리되고 있는 인스턴스는 garbage collection되지 않는다.** 라는 점을 주의해야 한다.  

### 메모리 이외의 리소스  

인스턴스를 공유하면 메모리 사용량 뿐만 아니라 여러 리소스의 양을 줄일 수 있다.  

* 시간  
인스턴스를 ```new```할 때에 일정 시간이 걸린다고 하면, 시간을 줄여 **프로그램의 속도를 올릴 수 있다.**는 것.  

* 파일 핸들이나 윈도우 패널 등  
OS에 따라서 동시에 사용할 수 있는 파일 핸들이나 윈도우 패널의 수에 제한을 두기도 한다.  
이 때 인스턴스를 공유해 놓지 않으면 그 제한 때문에 프로그램이 동작하지 않을 위험성이 있는데, 이를 해결해줄 수 있다.  

### 관련 패턴  
* Proxy 패턴  
Flyweight 패턴에서는 인스턴스 생성에 시간이 걸리는 경우, 공유에 따라서 처리 속도가 향상된다.  
* Composite 패턴  
Flyweight 패턴을 사용해서 Composite 패턴의 Leaf 역할을 공유시킬 수 있는 경우가 있다.  
* Singleton 패턴  
FlyweightFactory 역할을 Singleton 패턴이 되는 경우가 있다.  
Singleton 패턴의 Singleton 역할은 인스턴스를 하나만 만들기 때문에, **그 인스턴스가 사용되는 모든 곳에서 공유하게 된다.**  
**따라서 Singleton 역할의 인스턴스는 intrinsic한 정보만 가지고 있다.**
