# Template  

상위클래스에서 처리의 뼈대를 결정하고 하위 클래스에서 그 구체적인 내용을 결정하는 패턴.  
상위클래스에 템플릿에 해당하는 알고리즘 메소드가 정의되어 있고, 그 메소드 정의 내에는 추상 메소드가 사용된다.  
상위 클래스의 프로그램만 보면 추상 메소드를 어떻게 사용하고 있는지 알 수 있지만, 최종적으로 어떤 처리가 수행되는 지는 알 수 없다.  
실제 구현하는 것은 하위클래스이다. 서로 다른 하위클래스가 서로 다른 구현을 실행하면 서로 다른 처리가 실행될 것이다.


## 예제 1

**문자나 문자열을 5회 반복해서 표시하기**  

## 정리

### AbtractClass (추상 클래스)  

템플릿 메소드를 구현한다. 이 템플릿 메소드에서 사용하고 있는 추상 메소드를 선언한다.  
해당 추상 메소드들은 ConcreteClass에 의해 구현된다.  
예제 1에서는 AbstractDisplay가 이에 해당된다.  
AbstractDisplay의 템플릿 메소드는 display()이며, 추상 메소드는 open(), print(), closd()에 해당된다.

### ConcreteClass (구현 클래스)

AbstractClass에 정의되어 있는 추상 메소드를 구체적으로 구현한다.  
여기서 구현한 메소드는 AbstractClass의 템플릿 메소드에서 호출된다.  
예제 1에서는 CharDisplay나 StringDisplay가 이에 해당된다.

## Hint

### 왜 사용하는가?  

> 로직을 공통화할 수 있다.  

상위 클래스의 템플릿 메소드에 알고리즘이 기술되어 있으므로, 하위 클래스에서는 알고리즘을 일일이 기술할 필요가 없다.  
Template 패턴을 사용하지 않고, 일일이 복사/붙혀넣기를 통해 구현했다면, 한 메소드에서 버그가 발견되었을 때, 모든 소스를 고쳐야하는 문제점이 있다.  

### 상위 클래스와 하위 클래스의 연계

상위클래스에서 선언된 추상 메소드를 실제로 하위 클래스에서 구현할 때, 그 메소드가 어느 타이밍에서 호출되는 지를 이해해야한다.  
> 상위 클래스 소스가 없으면, 하위 클래스의 구현이 어려울 수도 있다.

### 하위 클래스를 상위 클래스와 동일시 해야한다.

예제 1의 Main에서는 CharDisplay, StringDisplay 모두 AbstractClass형 변수에 대입하고 있다. 그리고 상위 클래스의 메소드인 display()를 호출한다.  
이 때, instanceof 등으로 하위 클래스의 종류를 특정하지 않아도 프로그램이 작동하도록 만드는 것이 좋다.

> The Liskov Substitution Principle (LSP) : 어떠한 인프턴스를 대입해도 제대로 작동할 수 있도록 한다.

[LSP](https://ko.wikipedia.org/wiki/%EB%A6%AC%EC%8A%A4%EC%BD%94%ED%94%84_%EC%B9%98%ED%99%98_%EC%9B%90%EC%B9%99) 는 Template 패턴에 국한되지 않는 상속의 일반적인 원칙이디.  

### 관련 패턴

* Factory 패턴  
    Template 패턴을 인스턴스 생성에 응용한 전형적인 예가 Factory Pattern이다.
* Strategy 패턴
    Template 패턴에서는 '상속'을 이용해서 프로그램의 동작을 변경할 수 있다.  
    Strategy 패턴에서는 '위임'을 이용해서 프로그램의 동작을 변경할 수 있기 떄문에, 프로그램의 일부를 변경하기 보다는 알고리즘 전체를 완전히 바꾸고 있다.
