# Builder  

전체를 구성하고 있는 각 부분을 만들고 단계를 밟아 만들어 나가는, **인스턴스를 쌓아올리는 패턴**

## 예제 1

**문서를 작성하는 프로그램**

* Builder 클래스에는 문서를 작성하기 위한 추상 메소드만 선언되어 있다. (makeTitle, makeString...)
* Director 클래스에는 ```construct``` 메소드를 구현하여, 생성자의 파라미터를 Builder 하위클래스의 인스턴스로 받아, Builder의 메소드만을 사용하여 문서를 구성하는 역할을 한다.  
* Main 클래스에서는 ConcreteBuilder의 인스턴스를 생성하여, 그 인스턴스를 Director 클래스 생성자에게 전달한다. Director는 Builder의 함수만을 사용하여 문서를 작성한다.  
## 정리

### Builder

인스턴스를 생성하기 위한 인터페이스(API)를 결정한다.

### ConcreteBuilder    

Builder의 인터페이스를 구체적으로 구현한다.  
최종적인 결과를 얻는 메소드도 함께 정의되어 있다.

### Director 

Builder의 API를 사용해서, 인스턴스를 생성한다.  
ConcreteBuilder 역할에 의존한 프로그래밍은 수행하지 않는다.  
Builder의 API 만을 사용한다.  

## Hint

### 누가 무엇을 알고 있을까?

> 누가 무엇을 알고 있을까?

객체지향 프로그래밍에서 '누가 무엇을 알고있을까?' 라는 화두는 상당히 중요하다.  
어떤 클래스가 어떤 메소드를 사용할 수 있을까?에 주의하자.  

예제 1과 함께 보았을 때...
Main 클래스는 Builder 클래스의 메소드를 모른다. Director의 construct 메소드만을 호출한다.  
Director 안에서 Main함수 모르게 문서를 완성하는 로직을 진행한다.  
Director 클래스가 알고있는 것은 Builer 클래스이다.  
Director는 Builder 클래스의 API를 사용하지만, 실제로 어떤 클래스를 이용하고 있는지는 모른다.  
Director 가 Builder의 구체적인 하위 클래스를 모른다는 것은 **교체를 할 수 있다**는 의미이다.  
> 모르기 때문에 교환이 가능하고, 교체가 가능하기 때문에 부품으로서의 가치가 높다.  
> **교환가능성**에 대해서 설계자는 항상 기억하자. 

### 설계 시에 결정할 수 있는 것과 없는 것

> Builder 클래스는 목적 달성을 위해 필요 충분한 메소드군을 선언해둘 필요가 있다.  

> Builder 클래스는 앞으로 늘어날 지도 모르는 Builder의 하위 클래스의 요구에도 대응할 필요가 있다.  

> 가까운 미래에 발생할 것으로 예상되는 변화에 적응할 수 있도록 설계해야 한다.  

> 클래스를 수정/추가시, 클래스의 역할을 반드시 이해하고 나서 수정을 할 곳을 고민하는 습관을 갖자.  

### 관련 패턴

* Template 패턴  
Builder 패턴은 Director 역할이 Builder 역할을 제어한다.  
Template 패턴은 상위 클래스가 하위 클래스를 제어한다.  
* Composite 패턴  
Builder 패턴에 의해 만들어진 생성물은 Composite 패턴이 되는 경우가 있다.  
* Abstract Factory 패턴  
두 패턴 모두 복잡한 인스턴스를 생성한다.  
* Facade 패턴
Builder 패턴의 Director 역할은 복잡한 메소드를 조합하여 단순한 인터페이스(API)를 외부에 제공하는 역할  
Facade 패턴의 Facade 역할은 내부 모듈을 조합해서 작업하기 위한 단순한 인터페이스(API)를 외부에 제공한다.
